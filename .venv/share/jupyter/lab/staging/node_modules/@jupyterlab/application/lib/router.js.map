{"version":3,"file":"router.js","sourceRoot":"","sources":["../../../../application/src/router.ts"],"names":[],"mappings":"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","sourcesContent":["/*-----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\nimport { URLExt } from '@jupyterlab/coreutils';\n\nimport { CommandRegistry } from '@phosphor/commands';\n\nimport { ReadonlyJSONObject, Token } from '@phosphor/coreutils';\n\nimport { DisposableDelegate, IDisposable } from '@phosphor/disposable';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\n/* tslint:disable */\n/**\n * The URL Router token.\n */\nexport const IRouter = new Token<IRouter>('@jupyterlab/application:IRouter');\n/* tslint:enable */\n\n/**\n * A static class that routes URLs within the application.\n */\nexport interface IRouter {\n  /**\n   * The base URL for the router.\n   */\n  readonly base: string;\n\n  /**\n   * The command registry used by the router.\n   */\n  readonly commands: CommandRegistry;\n\n  /**\n   * The parsed current URL of the application.\n   */\n  readonly current: IRouter.ILocation;\n\n  /**\n   * A signal emitted when the router routes a route.\n   */\n  readonly routed: ISignal<IRouter, IRouter.ILocation>;\n\n  /**\n   * If a matching rule's command resolves with the `stop` token during routing,\n   * no further matches will execute.\n   */\n  readonly stop: Token<void>;\n\n  /**\n   * Navigate to a new path within the application.\n   *\n   * @param path - The new path or empty string if redirecting to root.\n   *\n   * @param options - The navigation options.\n   */\n  navigate(path: string, options?: IRouter.INavOptions): void;\n\n  /**\n   * Register a rule that maps a path pattern to a command.\n   *\n   * @param options - The route registration options.\n   *\n   * @returns A disposable that removes the registered rule from the router.\n   */\n  register(options: IRouter.IRegisterOptions): IDisposable;\n\n  /**\n   * Cause a hard reload of the document.\n   */\n  reload(): void;\n\n  /**\n   * Route a specific path to an action.\n   *\n   * @param url - The URL string that will be routed.\n   *\n   * #### Notes\n   * If a pattern is matched, its command will be invoked with arguments that\n   * match the `IRouter.ILocation` interface.\n   */\n  route(url: string): void;\n}\n\n/**\n * A namespace for the `IRouter` specification.\n */\nexport namespace IRouter {\n  /**\n   * The parsed location currently being routed.\n   */\n  export interface ILocation extends ReadonlyJSONObject {\n    /**\n     * The location hash.\n     */\n    hash: string;\n\n    /**\n     * The path that matched a routing pattern.\n     */\n    path: string;\n\n    /**\n     * The request being routed with the router `base` omitted.\n     *\n     * #### Notes\n     * This field includes the query string and hash, if they exist.\n     */\n    request: string;\n\n    /**\n     * The search element, including leading question mark (`'?'`), if any,\n     * of the path.\n     */\n    search: string;\n  }\n\n  /**\n   * The options passed into a navigation request.\n   */\n  export interface INavOptions {\n    /**\n     * Whether the navigation should be hard URL change instead of an HTML\n     * history API change.\n     */\n    hard?: boolean;\n\n    /**\n     * Whether the navigation should be added to the browser's history.\n     */\n    silent?: boolean;\n  }\n\n  /**\n   * The specification for registering a route with the router.\n   */\n  export interface IRegisterOptions {\n    /**\n     * The command string that will be invoked upon matching.\n     */\n    command: string;\n\n    /**\n     * The regular expression that will be matched against URLs.\n     */\n    pattern: RegExp;\n\n    /**\n     * The rank order of the registered rule. A lower rank denotes a higher\n     * priority. The default rank is `100`.\n     */\n    rank?: number;\n  }\n}\n\n/**\n * A static class that routes URLs within the application.\n */\nexport class Router implements IRouter {\n  /**\n   * Create a URL router.\n   */\n  constructor(options: Router.IOptions) {\n    this.base = options.base;\n    this.commands = options.commands;\n  }\n\n  /**\n   * The base URL for the router.\n   */\n  readonly base: string;\n\n  /**\n   * The command registry used by the router.\n   */\n  readonly commands: CommandRegistry;\n\n  /**\n   * Returns the parsed current URL of the application.\n   */\n  get current(): IRouter.ILocation {\n    const { base } = this;\n    const parsed = URLExt.parse(window.location.href);\n    const { search, hash } = parsed;\n    const path = parsed.pathname.replace(base, '');\n    const request = path + search + hash;\n\n    return { hash, path, request, search };\n  }\n\n  /**\n   * A signal emitted when the router routes a route.\n   */\n  get routed(): ISignal<this, IRouter.ILocation> {\n    return this._routed;\n  }\n\n  /**\n   * If a matching rule's command resolves with the `stop` token during routing,\n   * no further matches will execute.\n   */\n  readonly stop = new Token<void>('@jupyterlab/application:Router#stop');\n\n  /**\n   * Navigate to a new path within the application.\n   *\n   * @param path - The new path or empty string if redirecting to root.\n   *\n   * @param options - The navigation options.\n   */\n  navigate(path: string, options: IRouter.INavOptions = {}): void {\n    const url = path ? URLExt.join(this.base, path) : this.base;\n    const { history } = window;\n    const { hard, silent } = options;\n\n    if (silent) {\n      history.replaceState({}, '', url);\n    } else {\n      history.pushState({}, '', url);\n    }\n\n    if (hard) {\n      return this.reload();\n    }\n\n    // Because a `route()` call may still be in the stack after having received\n    // a `stop` token, wait for the next stack frame before calling `route()`.\n    requestAnimationFrame(() => {\n      this.route();\n    });\n  }\n\n  /**\n   * Register to route a path pattern to a command.\n   *\n   * @param options - The route registration options.\n   *\n   * @returns A disposable that removes the registered rule from the router.\n   */\n  register(options: IRouter.IRegisterOptions): IDisposable {\n    const { command, pattern } = options;\n    const rank = 'rank' in options ? options.rank : 100;\n    const rules = this._rules;\n\n    rules.set(pattern, { command, rank });\n\n    return new DisposableDelegate(() => {\n      rules.delete(pattern);\n    });\n  }\n\n  /**\n   * Cause a hard reload of the document.\n   */\n  reload(): void {\n    window.location.reload();\n  }\n\n  /**\n   * Route a specific path to an action.\n   *\n   * #### Notes\n   * If a pattern is matched, its command will be invoked with arguments that\n   * match the `IRouter.ILocation` interface.\n   */\n  route(): void {\n    const { commands, current, stop } = this;\n    const { request } = current;\n    const routed = this._routed;\n    const rules = this._rules;\n    const matches: Private.Rule[] = [];\n\n    // Collect all rules that match the URL.\n    rules.forEach((rule, pattern) => {\n      if (request.match(pattern)) {\n        matches.push(rule);\n      }\n    });\n\n    // Order the matching rules by rank and enqueue them.\n    const queue = matches.sort((a, b) => b.rank - a.rank);\n\n    // Process each enqueued command sequentially and short-circuit if a promise\n    // resolves with the `stop` token.\n    (function next() {\n      if (!queue.length) {\n        routed.emit(current);\n        return;\n      }\n\n      const { command } = queue.pop();\n\n      commands\n        .execute(command, current)\n        .then(result => {\n          if (result === stop) {\n            queue.length = 0;\n            console.log(`Routing ${request} was short-circuited by ${command}`);\n          }\n          next();\n        })\n        .catch(reason => {\n          console.warn(`Routing ${request} to ${command} failed`, reason);\n          next();\n        });\n    })();\n  }\n\n  private _routed = new Signal<this, IRouter.ILocation>(this);\n  private _rules = new Map<RegExp, Private.Rule>();\n}\n\n/**\n * A namespace for `Router` class statics.\n */\nexport namespace Router {\n  /**\n   * The options for instantiating a JupyterLab URL router.\n   */\n  export interface IOptions {\n    /**\n     * The fully qualified base URL for the router.\n     */\n    base: string;\n\n    /**\n     * The command registry used by the router.\n     */\n    commands: CommandRegistry;\n  }\n}\n\n/**\n * A namespace for private module data.\n */\nnamespace Private {\n  /**\n   * The internal representation of a routing rule.\n   */\n  export type Rule = { command: string; rank: number };\n}\n"]}