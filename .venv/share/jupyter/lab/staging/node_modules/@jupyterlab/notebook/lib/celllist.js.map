{"version":3,"file":"celllist.js","sourceRoot":"","sources":["../../../../notebook/src/celllist.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  ArrayExt,\n  IIterator,\n  IterableOrArrayLike,\n  each,\n  toArray,\n  ArrayIterator\n} from '@phosphor/algorithm';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { ICellModel } from '@jupyterlab/cells';\n\nimport {\n  IObservableMap,\n  ObservableMap,\n  IObservableList,\n  IObservableUndoableList,\n  IModelDB\n} from '@jupyterlab/observables';\n\nimport { NotebookModel } from './model';\n\n/**\n * A cell list object that supports undo/redo.\n */\nexport class CellList implements IObservableUndoableList<ICellModel> {\n  /**\n   * Construct the cell list.\n   */\n  constructor(modelDB: IModelDB, factory: NotebookModel.IContentFactory) {\n    this._factory = factory;\n    this._cellOrder = modelDB.createList<string>('cellOrder');\n    this._cellMap = new ObservableMap<ICellModel>();\n\n    this._cellOrder.changed.connect(this._onOrderChanged, this);\n  }\n\n  type: 'List';\n\n  /**\n   * A signal emitted when the cell list has changed.\n   */\n  get changed(): ISignal<this, IObservableList.IChangedArgs<ICellModel>> {\n    return this._changed;\n  }\n\n  /**\n   * Test whether the cell list has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Test whether the list is empty.\n   *\n   * @returns `true` if the cell list is empty, `false` otherwise.\n   *\n   * #### Notes\n   * This is a read-only property.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Iterator Validity\n   * No changes.\n   */\n  get isEmpty(): boolean {\n    return this._cellOrder.length === 0;\n  }\n\n  /**\n   * Get the length of the cell list.\n   *\n   * @return The number of cells in the cell list.\n   *\n   * #### Notes\n   * This is a read-only property.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Iterator Validity\n   * No changes.\n   */\n  get length(): number {\n    return this._cellOrder.length;\n  }\n\n  /**\n   * Create an iterator over the cells in the cell list.\n   *\n   * @returns A new iterator starting at the front of the cell list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Iterator Validity\n   * No changes.\n   */\n  iter(): IIterator<ICellModel> {\n    let arr: ICellModel[] = [];\n    for (let id of toArray(this._cellOrder)) {\n      arr.push(this._cellMap.get(id));\n    }\n    return new ArrayIterator<ICellModel>(arr);\n  }\n\n  /**\n   * Dispose of the resources held by the cell list.\n   */\n  dispose(): void {\n    if (this._isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n    // Clean up the cell map and cell order objects.\n    for (let cell of this._cellMap.values()) {\n      cell.dispose();\n    }\n    this._cellMap.dispose();\n    this._cellOrder.dispose();\n  }\n\n  /**\n   * Get the cell at the specified index.\n   *\n   * @param index - The positive integer index of interest.\n   *\n   * @returns The cell at the specified index.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Iterator Validity\n   * No changes.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral or out of range.\n   */\n  get(index: number): ICellModel {\n    return this._cellMap.get(this._cellOrder.get(index)) as ICellModel;\n  }\n\n  /**\n   * Set the cell at the specified index.\n   *\n   * @param index - The positive integer index of interest.\n   *\n   * @param cell - The cell to set at the specified index.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Iterator Validity\n   * No changes.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral or out of range.\n   *\n   * #### Notes\n   * This should be considered to transfer ownership of the\n   * cell to the `CellList`. As such, `cell.dispose()` should\n   * not be called by other actors.\n   */\n  set(index: number, cell: ICellModel): void {\n    // Set the internal data structures.\n    this._cellMap.set(cell.id, cell);\n    this._cellOrder.set(index, cell.id);\n  }\n\n  /**\n   * Add a cell to the back of the cell list.\n   *\n   * @param cell - The cell to add to the back of the cell list.\n   *\n   * @returns The new length of the cell list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Iterator Validity\n   * No changes.\n   *\n   * #### Notes\n   * This should be considered to transfer ownership of the\n   * cell to the `CellList`. As such, `cell.dispose()` should\n   * not be called by other actors.\n   */\n  push(cell: ICellModel): number {\n    // Set the internal data structures.\n    this._cellMap.set(cell.id, cell);\n    let num = this._cellOrder.push(cell.id);\n    return num;\n  }\n\n  /**\n   * Insert a cell into the cell list at a specific index.\n   *\n   * @param index - The index at which to insert the cell.\n   *\n   * @param cell - The cell to set at the specified index.\n   *\n   * @returns The new length of the cell list.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Iterator Validity\n   * No changes.\n   *\n   * #### Notes\n   * The `index` will be clamped to the bounds of the cell list.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Notes\n   * This should be considered to transfer ownership of the\n   * cell to the `CellList`. As such, `cell.dispose()` should\n   * not be called by other actors.\n   */\n  insert(index: number, cell: ICellModel): void {\n    // Set the internal data structures.\n    this._cellMap.set(cell.id, cell);\n    this._cellOrder.insert(index, cell.id);\n  }\n\n  /**\n   * Remove the first occurrence of a cell from the cell list.\n   *\n   * @param cell - The cell of interest.\n   *\n   * @returns The index of the removed cell, or `-1` if the cell\n   *   is not contained in the cell list.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Iterator Validity\n   * Iterators pointing at the removed cell and beyond are invalidated.\n   */\n  removeValue(cell: ICellModel): number {\n    let index = ArrayExt.findFirstIndex(\n      toArray(this._cellOrder),\n      id => this._cellMap.get(id) === cell\n    );\n    this.remove(index);\n    return index;\n  }\n\n  /**\n   * Remove and return the cell at a specific index.\n   *\n   * @param index - The index of the cell of interest.\n   *\n   * @returns The cell at the specified index, or `undefined` if the\n   *   index is out of range.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Iterator Validity\n   * Iterators pointing at the removed cell and beyond are invalidated.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   */\n  remove(index: number): ICellModel {\n    let id = this._cellOrder.get(index);\n    this._cellOrder.remove(index);\n    let cell = this._cellMap.get(id);\n    return cell;\n  }\n\n  /**\n   * Remove all cells from the cell list.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Iterator Validity\n   * All current iterators are invalidated.\n   */\n  clear(): void {\n    this._cellOrder.clear();\n  }\n\n  /**\n   * Move a cell from one index to another.\n   *\n   * @parm fromIndex - The index of the element to move.\n   *\n   * @param toIndex - The index to move the element to.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Iterator Validity\n   * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`\n   * and beyond are invalidated.\n   *\n   * #### Undefined Behavior\n   * A `fromIndex` or a `toIndex` which is non-integral.\n   */\n  move(fromIndex: number, toIndex: number): void {\n    this._cellOrder.move(fromIndex, toIndex);\n  }\n\n  /**\n   * Push a set of cells to the back of the cell list.\n   *\n   * @param cells - An iterable or array-like set of cells to add.\n   *\n   * @returns The new length of the cell list.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Iterator Validity\n   * No changes.\n   *\n   * #### Notes\n   * This should be considered to transfer ownership of the\n   * cells to the `CellList`. As such, `cell.dispose()` should\n   * not be called by other actors.\n   */\n  pushAll(cells: IterableOrArrayLike<ICellModel>): number {\n    let newValues = toArray(cells);\n    each(newValues, cell => {\n      // Set the internal data structures.\n      this._cellMap.set(cell.id, cell);\n      this._cellOrder.push(cell.id);\n    });\n    return this.length;\n  }\n\n  /**\n   * Insert a set of items into the cell list at the specified index.\n   *\n   * @param index - The index at which to insert the cells.\n   *\n   * @param cells - The cells to insert at the specified index.\n   *\n   * @returns The new length of the cell list.\n   *\n   * #### Complexity.\n   * Linear.\n   *\n   * #### Iterator Validity\n   * No changes.\n   *\n   * #### Notes\n   * The `index` will be clamped to the bounds of the cell list.\n   *\n   * #### Undefined Behavior.\n   * An `index` which is non-integral.\n   *\n   * #### Notes\n   * This should be considered to transfer ownership of the\n   * cells to the `CellList`. As such, `cell.dispose()` should\n   * not be called by other actors.\n   */\n  insertAll(index: number, cells: IterableOrArrayLike<ICellModel>): number {\n    let newValues = toArray(cells);\n    each(newValues, cell => {\n      this._cellMap.set(cell.id, cell);\n      this._cellOrder.beginCompoundOperation();\n      this._cellOrder.insert(index++, cell.id);\n      this._cellOrder.endCompoundOperation();\n    });\n    return this.length;\n  }\n\n  /**\n   * Remove a range of items from the cell list.\n   *\n   * @param startIndex - The start index of the range to remove (inclusive).\n   *\n   * @param endIndex - The end index of the range to remove (exclusive).\n   *\n   * @returns The new length of the cell list.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Iterator Validity\n   * Iterators pointing to the first removed cell and beyond are invalid.\n   *\n   * #### Undefined Behavior\n   * A `startIndex` or `endIndex` which is non-integral.\n   */\n  removeRange(startIndex: number, endIndex: number): number {\n    this._cellOrder.removeRange(startIndex, endIndex);\n    return this.length;\n  }\n\n  /**\n   * Whether the object can redo changes.\n   */\n  get canRedo(): boolean {\n    return this._cellOrder.canRedo;\n  }\n\n  /**\n   * Whether the object can undo changes.\n   */\n  get canUndo(): boolean {\n    return this._cellOrder.canUndo;\n  }\n\n  /**\n   * Begin a compound operation.\n   *\n   * @param isUndoAble - Whether the operation is undoable.\n   *   The default is `true`.\n   */\n  beginCompoundOperation(isUndoAble?: boolean): void {\n    this._cellOrder.beginCompoundOperation(isUndoAble);\n  }\n\n  /**\n   * End a compound operation.\n   */\n  endCompoundOperation(): void {\n    this._cellOrder.endCompoundOperation();\n  }\n\n  /**\n   * Undo an operation.\n   */\n  undo(): void {\n    this._cellOrder.undo();\n  }\n\n  /**\n   * Redo an operation.\n   */\n  redo(): void {\n    this._cellOrder.redo();\n  }\n\n  /**\n   * Clear the change stack.\n   */\n  clearUndo(): void {\n    // Dispose of cells not in the current\n    // cell order.\n    for (let key of this._cellMap.keys()) {\n      if (\n        ArrayExt.findFirstIndex(toArray(this._cellOrder), id => id === key) ===\n        -1\n      ) {\n        let cell = this._cellMap.get(key) as ICellModel;\n        cell.dispose();\n        this._cellMap.delete(key);\n      }\n    }\n    this._cellOrder.clearUndo();\n  }\n\n  private _onOrderChanged(\n    order: IObservableUndoableList<string>,\n    change: IObservableList.IChangedArgs<string>\n  ): void {\n    if (change.type === 'add' || change.type === 'set') {\n      each(change.newValues, id => {\n        if (!this._cellMap.has(id)) {\n          let cellDB = this._factory.modelDB;\n          let cellType = cellDB.createValue(id + '.type');\n          let cell: ICellModel;\n          switch (cellType.get()) {\n            case 'code':\n              cell = this._factory.createCodeCell({ id: id });\n              break;\n            case 'markdown':\n              cell = this._factory.createMarkdownCell({ id: id });\n              break;\n            default:\n              cell = this._factory.createRawCell({ id: id });\n              break;\n          }\n          this._cellMap.set(id, cell);\n        }\n      });\n    }\n    let newValues: ICellModel[] = [];\n    let oldValues: ICellModel[] = [];\n    each(change.newValues, id => {\n      newValues.push(this._cellMap.get(id));\n    });\n    each(change.oldValues, id => {\n      oldValues.push(this._cellMap.get(id));\n    });\n    this._changed.emit({\n      type: change.type,\n      oldIndex: change.oldIndex,\n      newIndex: change.newIndex,\n      oldValues,\n      newValues\n    });\n  }\n\n  private _isDisposed: boolean = false;\n  private _cellOrder: IObservableUndoableList<string> = null;\n  private _cellMap: IObservableMap<ICellModel> = null;\n  private _changed = new Signal<this, IObservableList.IChangedArgs<ICellModel>>(\n    this\n  );\n  private _factory: NotebookModel.IContentFactory = null;\n}\n"]}