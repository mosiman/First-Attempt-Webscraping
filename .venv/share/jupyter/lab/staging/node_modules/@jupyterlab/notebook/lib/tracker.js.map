{"version":3,"file":"tracker.js","sourceRoot":"","sources":["../../../../notebook/src/tracker.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;AAE3D,mDAAyE;AAIzE,mDAA4C;AAE5C,mDAAsD;AA8BtD,oBAAoB;AACpB;;GAEG;AACU,QAAA,gBAAgB,GAAG,IAAI,iBAAK,CACvC,uCAAuC,CACxC,CAAC;AACF,mBAAmB;AAEnB,qBAA6B,SAAQ,0BAA8B;IAAnE;;QAwFU,gBAAW,GAAgB,IAAI,CAAC;QAChC,uBAAkB,GAAG,IAAI,kBAAM,CAAa,IAAI,CAAC,CAAC;QAClD,sBAAiB,GAAG,IAAI,kBAAM,CAAa,IAAI,CAAC,CAAC;IAC3D,CAAC;IAzFC;;;;;;OAMG;IACH,IAAI,UAAU;QACZ,IAAI,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC;QAChC,IAAI,CAAC,MAAM,EAAE;YACX,OAAO,IAAI,CAAC;SACb;QACD,OAAO,MAAM,CAAC,OAAO,CAAC,UAAU,IAAI,IAAI,CAAC;IAC3C,CAAC;IAED;;;;;OAKG;IACH,IAAI,iBAAiB;QACnB,OAAO,IAAI,CAAC,kBAAkB,CAAC;IACjC,CAAC;IAED;;OAEG;IACH,IAAI,gBAAgB;QAClB,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAChC,CAAC;IAED;;;;OAIG;IACH,GAAG,CAAC,KAAoB;QACtB,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACjC,KAAK,CAAC,OAAO,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC;QACzE,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,CAAC,CAAC;QACvE,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;OAEG;IACH,OAAO;QACL,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,KAAK,CAAC,OAAO,EAAE,CAAC;IAClB,CAAC;IAED;;OAEG;IACO,gBAAgB,CAAC,MAAqB;QAC9C,yEAAyE;QACzE,IAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;QACjC,IAAI,UAAU,IAAI,UAAU,KAAK,IAAI,CAAC,WAAW,EAAE;YACjD,OAAO;SACR;QACD,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;QAE9B,IAAI,CAAC,MAAM,EAAE;YACX,OAAO;SACR;QAED,2EAA2E;QAC3E,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,IAAI,IAAI,CAAC,CAAC;IAClE,CAAC;IAEO,oBAAoB,CAAC,MAAgB,EAAE,IAAU;QACvD,qEAAqE;QACrE,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,KAAK,MAAM,EAAE;YAC/D,IAAI,CAAC,WAAW,GAAG,IAAI,IAAI,IAAI,CAAC;YAChC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SAChD;IACH,CAAC;IAEO,mBAAmB,CAAC,MAAgB;QAC1C,mEAAmE;QACnE,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,KAAK,MAAM,EAAE;YAC/D,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;SACrC;IACH,CAAC;CAKF;AA3FD,0CA2FC","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { IInstanceTracker, InstanceTracker } from '@jupyterlab/apputils';\n\nimport { Cell } from '@jupyterlab/cells';\n\nimport { Token } from '@phosphor/coreutils';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { NotebookPanel, Notebook } from './';\n\n/**\n * An object that tracks notebook widgets.\n */\nexport interface INotebookTracker extends IInstanceTracker<NotebookPanel> {\n  /**\n   * The currently focused cell.\n   *\n   * #### Notes\n   * If there is no cell with the focus, then this value is `null`.\n   */\n  readonly activeCell: Cell;\n\n  /**\n   * A signal emitted when the current active cell changes.\n   *\n   * #### Notes\n   * If there is no cell with the focus, then `null` will be emitted.\n   */\n  readonly activeCellChanged: ISignal<this, Cell>;\n\n  /**\n   * A signal emitted when the selection state changes.\n   */\n  readonly selectionChanged: ISignal<this, void>;\n}\n\n/* tslint:disable */\n/**\n * The notebook tracker token.\n */\nexport const INotebookTracker = new Token<INotebookTracker>(\n  '@jupyterlab/notebook:INotebookTracker'\n);\n/* tslint:enable */\n\nexport class NotebookTracker extends InstanceTracker<NotebookPanel>\n  implements INotebookTracker {\n  /**\n   * The currently focused cell.\n   *\n   * #### Notes\n   * This is a read-only property. If there is no cell with the focus, then this\n   * value is `null`.\n   */\n  get activeCell(): Cell {\n    let widget = this.currentWidget;\n    if (!widget) {\n      return null;\n    }\n    return widget.content.activeCell || null;\n  }\n\n  /**\n   * A signal emitted when the current active cell changes.\n   *\n   * #### Notes\n   * If there is no cell with the focus, then `null` will be emitted.\n   */\n  get activeCellChanged(): ISignal<this, Cell> {\n    return this._activeCellChanged;\n  }\n\n  /**\n   * A signal emitted when the selection state changes.\n   */\n  get selectionChanged(): ISignal<this, void> {\n    return this._selectionChanged;\n  }\n\n  /**\n   * Add a new notebook panel to the tracker.\n   *\n   * @param panel - The notebook panel being added.\n   */\n  add(panel: NotebookPanel): Promise<void> {\n    const promise = super.add(panel);\n    panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n    panel.content.selectionChanged.connect(this._onSelectionChanged, this);\n    return promise;\n  }\n\n  /**\n   * Dispose of the resources held by the tracker.\n   */\n  dispose(): void {\n    this._activeCell = null;\n    super.dispose();\n  }\n\n  /**\n   * Handle the current change event.\n   */\n  protected onCurrentChanged(widget: NotebookPanel): void {\n    // Store an internal reference to active cell to prevent false positives.\n    let activeCell = this.activeCell;\n    if (activeCell && activeCell === this._activeCell) {\n      return;\n    }\n    this._activeCell = activeCell;\n\n    if (!widget) {\n      return;\n    }\n\n    // Since the notebook has changed, immediately signal an active cell change\n    this._activeCellChanged.emit(widget.content.activeCell || null);\n  }\n\n  private _onActiveCellChanged(sender: Notebook, cell: Cell): void {\n    // Check if the active cell change happened for the current notebook.\n    if (this.currentWidget && this.currentWidget.content === sender) {\n      this._activeCell = cell || null;\n      this._activeCellChanged.emit(this._activeCell);\n    }\n  }\n\n  private _onSelectionChanged(sender: Notebook): void {\n    // Check if the selection change happened for the current notebook.\n    if (this.currentWidget && this.currentWidget.content === sender) {\n      this._selectionChanged.emit(void 0);\n    }\n  }\n\n  private _activeCell: Cell | null = null;\n  private _activeCellChanged = new Signal<this, Cell>(this);\n  private _selectionChanged = new Signal<this, void>(this);\n}\n"]}