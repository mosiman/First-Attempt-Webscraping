{"version":3,"file":"handler.js","sourceRoot":"","sources":["../../../../inspector/src/handler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { CodeEditor } from '@jupyterlab/codeeditor';\n\nimport { IDataConnector, Text } from '@jupyterlab/coreutils';\n\nimport { ReadonlyJSONObject } from '@phosphor/coreutils';\n\nimport { IDisposable } from '@phosphor/disposable';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { MimeModel, RenderMimeRegistry } from '@jupyterlab/rendermime';\n\nimport { IInspector } from './inspector';\n\n/**\n * An object that handles code inspection.\n */\nexport class InspectionHandler implements IDisposable, IInspector.IInspectable {\n  /**\n   * Construct a new inspection handler for a widget.\n   */\n  constructor(options: InspectionHandler.IOptions) {\n    this._connector = options.connector;\n    this._rendermime = options.rendermime;\n  }\n\n  /**\n   * A signal emitted when the handler is disposed.\n   */\n  get disposed(): ISignal<InspectionHandler, void> {\n    return this._disposed;\n  }\n\n  /**\n   * A signal emitted when inspector should clear all items with no history.\n   */\n  get ephemeralCleared(): ISignal<InspectionHandler, void> {\n    return this._ephemeralCleared;\n  }\n\n  /**\n   * A signal emitted when an inspector value is generated.\n   */\n  get inspected(): ISignal<InspectionHandler, IInspector.IInspectorUpdate> {\n    return this._inspected;\n  }\n\n  /**\n   * The editor widget used by the inspection handler.\n   */\n  get editor(): CodeEditor.IEditor | null {\n    return this._editor;\n  }\n  set editor(newValue: CodeEditor.IEditor | null) {\n    if (newValue === this._editor) {\n      return;\n    }\n\n    if (this._editor && !this._editor.isDisposed) {\n      this._editor.model.value.changed.disconnect(this.onTextChanged, this);\n    }\n    let editor = (this._editor = newValue);\n    if (editor) {\n      // Clear ephemeral inspectors in preparation for a new editor.\n      this._ephemeralCleared.emit(void 0);\n      editor.model.value.changed.connect(this.onTextChanged, this);\n    }\n  }\n\n  /**\n   * Indicates whether the handler makes API inspection requests or stands by.\n   *\n   * #### Notes\n   * The use case for this attribute is to limit the API traffic when no\n   * inspector is visible.\n   */\n  get standby(): boolean {\n    return this._standby;\n  }\n  set standby(value: boolean) {\n    this._standby = value;\n  }\n\n  /**\n   * Get whether the inspection handler is disposed.\n   *\n   * #### Notes\n   * This is a read-only property.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources used by the handler.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    this._disposed.emit(void 0);\n    Signal.clearData(this);\n  }\n\n  /**\n   * Handle a text changed signal from an editor.\n   *\n   * #### Notes\n   * Update the hints inspector based on a text change.\n   */\n  protected onTextChanged(): void {\n    // If the handler is in standby mode, bail.\n    if (this._standby) {\n      return;\n    }\n\n    const editor = this.editor;\n\n    if (!editor) {\n      return;\n    }\n\n    const text = editor.model.value.text;\n    const position = editor.getCursorPosition();\n    const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);\n    const update: IInspector.IInspectorUpdate = {\n      content: null,\n      type: 'hints'\n    };\n\n    const pending = ++this._pending;\n\n    this._connector\n      .fetch({ offset, text })\n      .then(reply => {\n        // If handler has been disposed or a newer request is pending, bail.\n        if (this.isDisposed || pending !== this._pending) {\n          this._inspected.emit(update);\n          return;\n        }\n\n        const { data } = reply;\n        const mimeType = this._rendermime.preferredMimeType(data);\n\n        if (mimeType) {\n          const widget = this._rendermime.createRenderer(mimeType);\n          const model = new MimeModel({ data });\n\n          widget.renderModel(model);\n          update.content = widget;\n        }\n\n        this._inspected.emit(update);\n      })\n      .catch(reason => {\n        // Since almost all failures are benign, fail silently.\n        this._inspected.emit(update);\n      });\n  }\n\n  private _connector: IDataConnector<\n    InspectionHandler.IReply,\n    void,\n    InspectionHandler.IRequest\n  >;\n  private _disposed = new Signal<this, void>(this);\n  private _editor: CodeEditor.IEditor | null = null;\n  private _ephemeralCleared = new Signal<InspectionHandler, void>(this);\n  private _inspected = new Signal<this, IInspector.IInspectorUpdate>(this);\n  private _isDisposed = false;\n  private _pending = 0;\n  private _rendermime: RenderMimeRegistry;\n  private _standby = true;\n}\n\n/**\n * A namespace for inspection handler statics.\n */\nexport namespace InspectionHandler {\n  /**\n   * The instantiation options for an inspection handler.\n   */\n  export interface IOptions {\n    /**\n     * The connector used to make inspection requests.\n     *\n     * #### Notes\n     * The only method of this connector that will ever be called is `fetch`, so\n     * it is acceptable for the other methods to be simple functions that return\n     * rejected promises.\n     */\n    connector: IDataConnector<IReply, void, IRequest>;\n\n    /**\n     * The mime renderer for the inspection handler.\n     */\n    rendermime: RenderMimeRegistry;\n  }\n\n  /**\n   * A reply to an inspection request.\n   */\n  export interface IReply {\n    /**\n     * The MIME bundle data returned from an inspection request.\n     */\n    data: ReadonlyJSONObject;\n\n    /**\n     * Any metadata that accompanies the MIME bundle returning from a request.\n     */\n    metadata: ReadonlyJSONObject;\n  }\n\n  /**\n   * The details of an inspection request.\n   */\n  export interface IRequest {\n    /**\n     * The cursor offset position within the text being inspected.\n     */\n    offset: number;\n\n    /**\n     * The text being inspected.\n     */\n    text: string;\n  }\n}\n"]}