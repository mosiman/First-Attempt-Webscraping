{"version":3,"file":"model.js","sourceRoot":"","sources":["../../../../completer/src/model.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  IIterator,\n  IterableOrArrayLike,\n  iter,\n  map,\n  toArray\n} from '@phosphor/algorithm';\n\nimport { JSONExt } from '@phosphor/coreutils';\n\nimport { StringExt } from '@phosphor/algorithm';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { Completer } from './widget';\n\n/**\n * An implementation of a completer model.\n */\nexport class CompleterModel implements Completer.IModel {\n  /**\n   * A signal emitted when state of the completer menu changes.\n   */\n  get stateChanged(): ISignal<this, void> {\n    return this._stateChanged;\n  }\n\n  /**\n   * The original completion request details.\n   */\n  get original(): Completer.ITextState | null {\n    return this._original;\n  }\n  set original(newValue: Completer.ITextState | null) {\n    let unchanged =\n      this._original === newValue ||\n      (this._original &&\n        newValue &&\n        JSONExt.deepEqual(newValue, this._original));\n    if (unchanged) {\n      return;\n    }\n\n    this._reset();\n\n    // Set both the current and original to the same value when original is set.\n    this._current = this._original = newValue;\n\n    this._stateChanged.emit(undefined);\n  }\n\n  /**\n   * The current text change details.\n   */\n  get current(): Completer.ITextState | null {\n    return this._current;\n  }\n  set current(newValue: Completer.ITextState | null) {\n    const unchanged =\n      this._current === newValue ||\n      (this._current && newValue && JSONExt.deepEqual(newValue, this._current));\n\n    if (unchanged) {\n      return;\n    }\n\n    const original = this._original;\n\n    // Original request must always be set before a text change. If it isn't\n    // the model fails silently.\n    if (!original) {\n      return;\n    }\n\n    const cursor = this._cursor;\n\n    // Cursor must always be set before a text change. This happens\n    // automatically in the completer handler, but since `current` is a public\n    // attribute, this defensive check is necessary.\n    if (!cursor) {\n      return;\n    }\n\n    const current = (this._current = newValue);\n\n    if (!current) {\n      this._stateChanged.emit(undefined);\n      return;\n    }\n\n    const originalLine = original.text.split('\\n')[original.line];\n    const currentLine = current.text.split('\\n')[current.line];\n\n    // If the text change means that the original start point has been preceded,\n    // then the completion is no longer valid and should be reset.\n    if (currentLine.length < originalLine.length) {\n      this.reset(true);\n      return;\n    }\n\n    const { start, end } = this._cursor;\n    // Clip the front of the current line.\n    let query = current.text.substring(start);\n    // Clip the back of the current line by calculating the end of the original.\n    const ending = original.text.substring(end);\n    query = query.substring(0, query.lastIndexOf(ending));\n    this._query = query;\n    this._stateChanged.emit(undefined);\n  }\n\n  /**\n   * The cursor details that the API has used to return matching options.\n   */\n  get cursor(): Completer.ICursorSpan | null {\n    return this._cursor;\n  }\n  set cursor(newValue: Completer.ICursorSpan | null) {\n    // Original request must always be set before a cursor change. If it isn't\n    // the model fails silently.\n    if (!this.original) {\n      return;\n    }\n    this._cursor = newValue;\n  }\n\n  /**\n   * The query against which items are filtered.\n   */\n  get query(): string {\n    return this._query;\n  }\n  set query(newValue: string) {\n    this._query = newValue;\n  }\n\n  /**\n   * A flag that is true when the model value was modified by a subset match.\n   */\n  get subsetMatch(): boolean {\n    return this._subsetMatch;\n  }\n  set subsetMatch(newValue: boolean) {\n    this._subsetMatch = newValue;\n  }\n\n  /**\n   * Get whether the model is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources held by the model.\n   */\n  dispose(): void {\n    // Do nothing if already disposed.\n    if (this._isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n  }\n\n  /**\n   * The list of visible items in the completer menu.\n   *\n   * #### Notes\n   * This is a read-only property.\n   */\n  items(): IIterator<Completer.IItem> {\n    return this._filter();\n  }\n\n  /**\n   * The unfiltered list of all available options in a completer menu.\n   */\n  options(): IIterator<string> {\n    return iter(this._options);\n  }\n\n  /**\n   * The map from identifiers (a.b) to types (function, module, class, instance,\n   * etc.).\n   *\n   * #### Notes\n   * A type map is currently only provided by the latest IPython kernel using\n   * the completer reply metadata field `_jupyter_types_experimental`. The\n   * values are completely up to the kernel.\n   *\n   */\n  typeMap(): Completer.TypeMap {\n    return this._typeMap;\n  }\n\n  /**\n   * An ordered list of all the known types in the typeMap.\n   *\n   * #### Notes\n   * To visually encode the types of the completer matches, we assemble an\n   * ordered list. This list begins with:\n   * ```\n   * ['function', 'instance', 'class', 'module', 'keyword']\n   * ```\n   * and then has any remaining types listed alphebetically. This will give\n   * reliable visual encoding for these known types, but allow kernels to\n   * provide new types.\n   */\n  orderedTypes(): string[] {\n    return this._orderedTypes;\n  }\n\n  /**\n   * Set the available options in the completer menu.\n   */\n  setOptions(\n    newValue: IterableOrArrayLike<string>,\n    typeMap?: Completer.TypeMap\n  ) {\n    const values = toArray(newValue || []);\n    const types = typeMap || {};\n\n    if (\n      JSONExt.deepEqual(values, this._options) &&\n      JSONExt.deepEqual(types, this._typeMap)\n    ) {\n      return;\n    }\n    if (values.length) {\n      this._options = values;\n      this._typeMap = types;\n      this._orderedTypes = Private.findOrderedTypes(types);\n      this._subsetMatch = true;\n    } else {\n      this._options = [];\n      this._typeMap = {};\n      this._orderedTypes = [];\n    }\n    this._stateChanged.emit(undefined);\n  }\n\n  /**\n   * Handle a cursor change.\n   */\n  handleCursorChange(change: Completer.ITextState): void {\n    // If there is no active completion, return.\n    if (!this._original) {\n      return;\n    }\n\n    const { column, line } = change;\n    const { original } = this;\n\n    if (!original) {\n      return;\n    }\n\n    // If a cursor change results in a the cursor being on a different line\n    // than the original request, cancel.\n    if (line !== original.line) {\n      this.reset(true);\n      return;\n    }\n\n    // If a cursor change results in the cursor being set to a position that\n    // precedes the original request, cancel.\n    if (column < original.column) {\n      this.reset(true);\n      return;\n    }\n\n    const { cursor, current } = this;\n\n    if (!cursor || !current) {\n      return;\n    }\n\n    // If a cursor change results in the cursor being set to a position beyond\n    // the end of the area that would be affected by completion, cancel.\n    const cursorDelta = cursor.end - cursor.start;\n    const originalLine = original.text.split('\\n')[original.line];\n    const currentLine = current.text.split('\\n')[current.line];\n    const inputDelta = currentLine.length - originalLine.length;\n\n    if (column > original.column + cursorDelta + inputDelta) {\n      this.reset(true);\n      return;\n    }\n  }\n\n  /**\n   * Handle a text change.\n   */\n  handleTextChange(change: Completer.ITextState): void {\n    const original = this._original;\n\n    // If there is no active completion, return.\n    if (!original) {\n      return;\n    }\n\n    // When the completer detects a common subset prefix for all options,\n    // it updates the model and sets the model source to that value, but this\n    // text change should be ignored.\n    if (this._subsetMatch) {\n      return;\n    }\n\n    const { text, column, line } = change;\n    const last = text.split('\\n')[line][column - 1];\n\n    // If last character entered is not whitespace or if the change column is\n    // greater than or equal to the original column, update completion.\n    if ((last && last.match(/\\S/)) || change.column >= original.column) {\n      this.current = change;\n      return;\n    }\n\n    // If final character is whitespace, reset completion.\n    this.reset(true);\n  }\n\n  /**\n   * Create a resolved patch between the original state and a patch string.\n   *\n   * @param patch - The patch string to apply to the original value.\n   *\n   * @returns A patched text change or undefined if original value did not exist.\n   */\n  createPatch(patch: string): Completer.IPatch | undefined {\n    const original = this._original;\n    const cursor = this._cursor;\n\n    if (!original || !cursor) {\n      return undefined;\n    }\n\n    const { start, end } = cursor;\n    const { text } = original;\n    const prefix = text.substring(0, start);\n    const suffix = text.substring(end);\n\n    return { offset: (prefix + patch).length, text: prefix + patch + suffix };\n  }\n\n  /**\n   * Reset the state of the model and emit a state change signal.\n   *\n   * @param hard - Reset even if a subset match is in progress.\n   */\n  reset(hard = false) {\n    // When the completer detects a common subset prefix for all options,\n    // it updates the model and sets the model source to that value, triggering\n    // a reset. Unless explicitly a hard reset, this should be ignored.\n    if (!hard && this._subsetMatch) {\n      return;\n    }\n    this._subsetMatch = false;\n    this._reset();\n    this._stateChanged.emit(undefined);\n  }\n\n  /**\n   * Apply the query to the complete options list to return the matching subset.\n   */\n  private _filter(): IIterator<Completer.IItem> {\n    let options = this._options || [];\n    let query = this._query;\n    if (!query) {\n      return map(options, option => ({ raw: option, text: option }));\n    }\n    let results: Private.IMatch[] = [];\n    for (let option of options) {\n      let match = StringExt.matchSumOfSquares(option, query);\n      if (match) {\n        let marked = StringExt.highlight(option, match.indices, Private.mark);\n        results.push({\n          raw: option,\n          score: match.score,\n          text: marked.join('')\n        });\n      }\n    }\n    return map(results.sort(Private.scoreCmp), result => ({\n      text: result.text,\n      raw: result.raw\n    }));\n  }\n\n  /**\n   * Reset the state of the model.\n   */\n  private _reset(): void {\n    this._current = null;\n    this._cursor = null;\n    this._options = [];\n    this._original = null;\n    this._query = '';\n    this._subsetMatch = false;\n    this._typeMap = {};\n    this._orderedTypes = [];\n  }\n\n  private _current: Completer.ITextState | null = null;\n  private _cursor: Completer.ICursorSpan | null = null;\n  private _isDisposed = false;\n  private _options: string[] = [];\n  private _original: Completer.ITextState | null = null;\n  private _query = '';\n  private _subsetMatch = false;\n  private _typeMap: Completer.TypeMap = {};\n  private _orderedTypes: string[] = [];\n  private _stateChanged = new Signal<this, void>(this);\n}\n\n/**\n * A namespace for completer model private data.\n */\nnamespace Private {\n  /**\n   * The list of known type annotations of completer matches.\n   */\n  const KNOWN_TYPES = ['function', 'instance', 'class', 'module', 'keyword'];\n\n  /**\n   * The map of known type annotations of completer matches.\n   */\n  const KNOWN_MAP = KNOWN_TYPES.reduce(\n    (acc, type) => {\n      acc[type] = null;\n      return acc;\n    },\n    {} as Completer.TypeMap\n  );\n\n  /**\n   * A filtered completion menu matching result.\n   */\n  export interface IMatch {\n    /**\n     * The raw text of a completion match.\n     */\n    raw: string;\n\n    /**\n     * A score which indicates the strength of the match.\n     *\n     * A lower score is better. Zero is the best possible score.\n     */\n    score: number;\n\n    /**\n     * The highlighted text of a completion match.\n     */\n    text: string;\n  }\n\n  /**\n   * Mark a highlighted chunk of text.\n   */\n  export function mark(value: string): string {\n    return `<mark>${value}</mark>`;\n  }\n\n  /**\n   * A sort comparison function for item match scores.\n   *\n   * #### Notes\n   * This orders the items first based on score (lower is better), then\n   * by locale order of the item text.\n   */\n  export function scoreCmp(a: IMatch, b: IMatch): number {\n    let delta = a.score - b.score;\n    if (delta !== 0) {\n      return delta;\n    }\n    return a.raw.localeCompare(b.raw);\n  }\n\n  /**\n   * Compute a reliably ordered list of types.\n   *\n   * #### Notes\n   * The resulting list always begins with the known types:\n   * ```\n   * ['function', 'instance', 'class', 'module', 'keyword']\n   * ```\n   * followed by other types in alphabetical order.\n   */\n  export function findOrderedTypes(typeMap: Completer.TypeMap): string[] {\n    const filtered = Object.keys(typeMap)\n      .map(key => typeMap[key])\n      .filter(value => value && !(value in KNOWN_MAP))\n      .sort((a, b) => a.localeCompare(b));\n\n    return KNOWN_TYPES.concat(filtered);\n  }\n}\n"]}