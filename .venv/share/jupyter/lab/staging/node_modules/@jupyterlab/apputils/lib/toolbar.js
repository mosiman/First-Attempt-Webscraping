"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
const algorithm_1 = require("@phosphor/algorithm");
const messaging_1 = require("@phosphor/messaging");
const properties_1 = require("@phosphor/properties");
const widgets_1 = require("@phosphor/widgets");
const styling_1 = require("./styling");
/**
 * The class name added to toolbars.
 */
const TOOLBAR_CLASS = 'jp-Toolbar';
/**
 * The class name added to toolbar items.
 */
const TOOLBAR_ITEM_CLASS = 'jp-Toolbar-item';
/**
 * The class name added to toolbar buttons.
 */
const TOOLBAR_BUTTON_CLASS = 'jp-Toolbar-button';
/**
 * The class name added to toolbar interrupt button.
 */
const TOOLBAR_INTERRUPT_CLASS = 'jp-StopIcon';
/**
 * The class name added to toolbar restart button.
 */
const TOOLBAR_RESTART_CLASS = 'jp-RefreshIcon';
/**
 * The class name added to toolbar kernel name text.
 */
const TOOLBAR_KERNEL_NAME_CLASS = 'jp-Toolbar-kernelName';
/**
 * The class name added to toolbar spacer.
 */
const TOOLBAR_SPACER_CLASS = 'jp-Toolbar-spacer';
/**
 * The class name added to toolbar kernel status icon.
 */
const TOOLBAR_KERNEL_STATUS_CLASS = 'jp-Toolbar-kernelStatus';
/**
 * The class name added to a busy kernel indicator.
 */
const TOOLBAR_BUSY_CLASS = 'jp-FilledCircleIcon';
const TOOLBAR_IDLE_CLASS = 'jp-CircleIcon';
/**
 * A layout for toolbars.
 *
 * #### Notes
 * This layout automatically collapses its height if there are no visible
 * toolbar widgets, and expands to the standard toolbar height if there are
 * visible toolbar widgets.
 */
class ToolbarLayout extends widgets_1.PanelLayout {
    constructor() {
        super(...arguments);
        this._dirty = false;
    }
    /**
     * A message handler invoked on a `'fit-request'` message.
     *
     * If any child widget is visible, expand the toolbar height to the normal
     * toolbar height.
     */
    onFitRequest(msg) {
        super.onFitRequest(msg);
        if (this.parent.isAttached) {
            // If there are any widgets not explicitly hidden, expand the toolbar to
            // accommodate them.
            if (algorithm_1.some(this.widgets, w => !w.isHidden)) {
                this.parent.node.style.minHeight = 'var(--jp-private-toolbar-height)';
            }
            else {
                this.parent.node.style.minHeight = '';
            }
        }
        // Set the dirty flag to ensure only a single update occurs.
        this._dirty = true;
        // Notify the ancestor that it should fit immediately. This may
        // cause a resize of the parent, fulfilling the required update.
        if (this.parent.parent) {
            messaging_1.MessageLoop.sendMessage(this.parent.parent, widgets_1.Widget.Msg.FitRequest);
        }
        // If the dirty flag is still set, the parent was not resized.
        // Trigger the required update on the parent widget immediately.
        if (this._dirty) {
            messaging_1.MessageLoop.sendMessage(this.parent, widgets_1.Widget.Msg.UpdateRequest);
        }
    }
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    onUpdateRequest(msg) {
        super.onUpdateRequest(msg);
        if (this.parent.isVisible) {
            this._dirty = false;
        }
    }
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    onChildShown(msg) {
        super.onChildShown(msg);
        // Post a fit request for the parent widget.
        this.parent.fit();
    }
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    onChildHidden(msg) {
        super.onChildHidden(msg);
        // Post a fit request for the parent widget.
        this.parent.fit();
    }
    /**
     * A message handler invoked on a `'before-attach'` message.
     */
    onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        // Post a fit request for the parent widget.
        this.parent.fit();
    }
    /**
     * Attach a widget to the parent's DOM node.
     *
     * @param index - The current index of the widget in the layout.
     *
     * @param widget - The widget to attach to the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    attachWidget(index, widget) {
        super.attachWidget(index, widget);
        // Post a fit request for the parent widget.
        this.parent.fit();
    }
    /**
     * Detach a widget from the parent's DOM node.
     *
     * @param index - The previous index of the widget in the layout.
     *
     * @param widget - The widget to detach from the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    detachWidget(index, widget) {
        super.detachWidget(index, widget);
        // Post a fit request for the parent widget.
        this.parent.fit();
    }
}
/**
 * A class which provides a toolbar widget.
 */
class Toolbar extends widgets_1.Widget {
    /**
     * Construct a new toolbar widget.
     */
    constructor() {
        super();
        this.addClass(TOOLBAR_CLASS);
        this.layout = new ToolbarLayout();
    }
    /**
     * Get an iterator over the ordered toolbar item names.
     *
     * @returns An iterator over the toolbar item names.
     */
    names() {
        let layout = this.layout;
        return algorithm_1.map(layout.widgets, widget => {
            return Private.nameProperty.get(widget);
        });
    }
    /**
     * Add an item to the end of the toolbar.
     *
     * @param name - The name of the widget to add to the toolbar.
     *
     * @param widget - The widget to add to the toolbar.
     *
     * @param index - The optional name of the item to insert after.
     *
     * @returns Whether the item was added to toolbar.  Returns false if
     *   an item of the same name is already in the toolbar.
     *
     * #### Notes
     * The item can be removed from the toolbar by setting its parent to `null`.
     */
    addItem(name, widget) {
        let layout = this.layout;
        return this.insertItem(layout.widgets.length, name, widget);
    }
    /**
     * Insert an item into the toolbar at the specified index.
     *
     * @param index - The index at which to insert the item.
     *
     * @param name - The name of the item.
     *
     * @param widget - The widget to add.
     *
     * @returns Whether the item was added to the toolbar. Returns false if
     *   an item of the same name is already in the toolbar.
     *
     * #### Notes
     * The index will be clamped to the bounds of the items.
     * The item can be removed from the toolbar by setting its parent to `null`.
     */
    insertItem(index, name, widget) {
        let existing = algorithm_1.find(this.names(), value => value === name);
        if (existing) {
            return false;
        }
        widget.addClass(TOOLBAR_ITEM_CLASS);
        let layout = this.layout;
        layout.insertWidget(index, widget);
        Private.nameProperty.set(widget, name);
        return true;
    }
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'click':
                if (!this.node.contains(document.activeElement) && this.parent) {
                    this.parent.activate();
                }
                break;
            default:
                break;
        }
    }
    /**
     * Handle `after-attach` messages for the widget.
     */
    onAfterAttach(msg) {
        this.node.addEventListener('click', this);
    }
    /**
     * Handle `before-detach` messages for the widget.
     */
    onBeforeDetach(msg) {
        this.node.removeEventListener('click', this);
    }
}
exports.Toolbar = Toolbar;
/**
 * The namespace for Toolbar class statics.
 */
(function (Toolbar) {
    /**
     * Create a toolbar item for a command or `null` if the command does not exist
     * in the registry.
     *
     * Notes:
     * If the command has an icon label it will be added to the button.
     * If there is no icon label, and no icon class, the main label will
     * be added.
     */
    function createFromCommand(commands, id) {
        if (!commands.hasCommand(id)) {
            return null;
        }
        const button = new ToolbarButton({
            onClick: () => {
                commands.execute(id);
                button.node.blur();
            },
            className: Private.commandClassName(commands, id),
            tooltip: Private.commandTooltip(commands, id)
        });
        let oldClasses = Private.commandClassName(commands, id).split(/\s/);
        button.node.disabled = !commands.isEnabled(id);
        Private.setNodeContentFromCommand(button.node, commands, id);
        // Ensure that we pick up relevant changes to the command:
        function onChange(sender, args) {
            if (args.id !== id) {
                return; // Not our command
            }
            if (args.type === 'removed') {
                // Dispose of button
                button.dispose();
                return;
            }
            if (args.type !== 'changed') {
                return;
            }
            // Update all fields (onClick is already indirected)
            const newClasses = Private.commandClassName(sender, id).split(/\s/);
            for (let cls of oldClasses) {
                if (cls && newClasses.indexOf(cls) === -1) {
                    button.removeClass(cls);
                }
            }
            for (let cls of newClasses) {
                if (cls && oldClasses.indexOf(cls) === -1) {
                    button.addClass(cls);
                }
            }
            oldClasses = newClasses;
            button.node.title = Private.commandTooltip(sender, id);
            Private.setNodeContentFromCommand(button.node, sender, id);
            button.node.disabled = !sender.isEnabled(id);
        }
        commands.commandChanged.connect(onChange, button);
        return button;
    }
    Toolbar.createFromCommand = createFromCommand;
    /**
     * Create an interrupt toolbar item.
     */
    function createInterruptButton(session) {
        return new ToolbarButton({
            className: TOOLBAR_INTERRUPT_CLASS,
            onClick: () => {
                if (session.kernel) {
                    session.kernel.interrupt();
                }
            },
            tooltip: 'Interrupt the kernel'
        });
    }
    Toolbar.createInterruptButton = createInterruptButton;
    /**
     * Create a restart toolbar item.
     */
    function createRestartButton(session) {
        return new ToolbarButton({
            className: TOOLBAR_RESTART_CLASS,
            onClick: () => {
                session.restart();
            },
            tooltip: 'Restart the kernel'
        });
    }
    Toolbar.createRestartButton = createRestartButton;
    /**
     * Create a toolbar spacer item.
     *
     * #### Notes
     * It is a flex spacer that separates the left toolbar items
     * from the right toolbar items.
     */
    function createSpacerItem() {
        return new Private.Spacer();
    }
    Toolbar.createSpacerItem = createSpacerItem;
    /**
     * Create a kernel name indicator item.
     *
     * #### Notes
     * It will display the `'display_name`' of the current kernel,
     * or `'No Kernel!'` if there is no kernel.
     * It can handle a change in context or kernel.
     */
    function createKernelNameItem(session) {
        return new Private.KernelName(session);
    }
    Toolbar.createKernelNameItem = createKernelNameItem;
    /**
     * Create a kernel status indicator item.
     *
     * #### Notes
     * It show display a busy status if the kernel status is
     * not idle.
     * It will show the current status in the node title.
     * It can handle a change to the context or the kernel.
     */
    function createKernelStatusItem(session) {
        return new Private.KernelStatus(session);
    }
    Toolbar.createKernelStatusItem = createKernelStatusItem;
})(Toolbar = exports.Toolbar || (exports.Toolbar = {}));
/**
 * A widget which acts as a button in a toolbar.
 */
class ToolbarButton extends widgets_1.Widget {
    /**
     * Construct a new toolbar button.
     */
    constructor(options = {}) {
        super({ node: document.createElement('button') });
        styling_1.Styling.styleNodeByTag(this.node, 'button');
        this.addClass(TOOLBAR_BUTTON_CLASS);
        this._onClick = options.onClick || Private.noOp;
        const classes = options.className
            ? options.className
                .trim()
                .replace(/\s{2,}/g, ' ')
                .split(/\s/)
            : null;
        if (classes) {
            classes.forEach(name => {
                this.addClass(name);
            });
        }
        this.node.title = options.tooltip || '';
    }
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'click':
                if (event.button === 0) {
                    this._onClick();
                }
                break;
            default:
                break;
        }
    }
    /**
     * Handle `after-attach` messages for the widget.
     */
    onAfterAttach(msg) {
        this.node.addEventListener('click', this);
    }
    /**
     * Handle `before-detach` messages for the widget.
     */
    onBeforeDetach(msg) {
        this.node.removeEventListener('click', this);
    }
}
exports.ToolbarButton = ToolbarButton;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for the name of a toolbar item.
     */
    Private.nameProperty = new properties_1.AttachedProperty({
        name: 'name',
        create: () => ''
    });
    /**
     * ToolbarButton tooltip formatter for a command.
     */
    function commandTooltip(commands, id) {
        return commands.caption(id);
    }
    Private.commandTooltip = commandTooltip;
    /**
     * A no-op function.
     */
    function noOp() {
        /* no-op */
    }
    Private.noOp = noOp;
    /**
     * Get the class names for a command based ToolBarButton
     */
    function commandClassName(commands, id) {
        let name = commands.className(id);
        // Add the boolean state classes.
        if (commands.isToggled(id)) {
            name += ' p-mod-toggled';
        }
        if (!commands.isVisible(id)) {
            name += ' p-mod-hidden';
        }
        return name;
    }
    Private.commandClassName = commandClassName;
    /**
     * Fill the node of a command based ToolBarButton.
     */
    function setNodeContentFromCommand(node, commands, id) {
        const iconClass = commands.iconClass(id);
        const iconLabel = commands.iconLabel(id);
        const label = commands.label(id);
        node.innerHTML = '';
        if (iconClass) {
            node.className += ` ${iconClass}`;
            node.setAttribute('title', iconLabel || label);
        }
        else {
            node.innerText = label;
        }
    }
    Private.setNodeContentFromCommand = setNodeContentFromCommand;
    /**
     * A spacer widget.
     */
    class Spacer extends widgets_1.Widget {
        /**
         * Construct a new spacer widget.
         */
        constructor() {
            super();
            this.addClass(TOOLBAR_SPACER_CLASS);
        }
    }
    Private.Spacer = Spacer;
    /**
     * A kernel name widget.
     */
    class KernelName extends ToolbarButton {
        /**
         * Construct a new kernel name widget.
         */
        constructor(session) {
            super({
                className: TOOLBAR_KERNEL_NAME_CLASS,
                onClick: () => {
                    session.selectKernel();
                },
                tooltip: 'Switch kernel'
            });
            this._onKernelChanged(session);
            session.kernelChanged.connect(this._onKernelChanged, this);
        }
        /**
         * Update the text of the kernel name item.
         */
        _onKernelChanged(session) {
            this.node.textContent = session.kernelDisplayName;
        }
    }
    Private.KernelName = KernelName;
    /**
     * A toolbar item that displays kernel status.
     */
    class KernelStatus extends widgets_1.Widget {
        /**
         * Construct a new kernel status widget.
         */
        constructor(session) {
            super();
            this.addClass(TOOLBAR_KERNEL_STATUS_CLASS);
            this._onStatusChanged(session);
            session.statusChanged.connect(this._onStatusChanged, this);
        }
        /**
         * Handle a status on a kernel.
         */
        _onStatusChanged(session) {
            if (this.isDisposed) {
                return;
            }
            let status = session.status;
            this.toggleClass(TOOLBAR_IDLE_CLASS, status === 'idle');
            this.toggleClass(TOOLBAR_BUSY_CLASS, status !== 'idle');
            let title = 'Kernel ' + status[0].toUpperCase() + status.slice(1);
            this.node.title = title;
        }
    }
    Private.KernelStatus = KernelStatus;
})(Private || (Private = {}));
